<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.theory.core.theoryRoot org.eventb.core.configuration="org.eventb.theory.core.thy">
<org.eventb.theory.core.newOperatorDefinition name="1" org.eventb.core.label="BNum" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.directOperatorDefinition name="'" org.eventb.theory.core.formula="List(pNat) × pNat"/>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.newOperatorDefinition name="3" org.eventb.core.label="BNumList" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="BNum" org.eventb.core.identifier="BaseNum"/>
<org.eventb.theory.core.directOperatorDefinition name="(" org.eventb.theory.core.formula="prj1(BaseNum)"/>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.newOperatorDefinition name="4" org.eventb.core.label="BNumBase" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.directOperatorDefinition name="'" org.eventb.theory.core.formula="prj2(BaseNum)"/>
<org.eventb.theory.core.operatorArgument name="(" org.eventb.core.expression="BNum" org.eventb.core.identifier="BaseNum"/>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.newOperatorDefinition name="/" org.eventb.core.label="BaseNIsZeroInternal" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="false" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="List(pNat)" org.eventb.core.identifier="L"/>
<org.eventb.theory.core.recursiveOperatorDefinition name="(" org.eventb.theory.core.inductiveArgument="L">
<org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="nil" org.eventb.theory.core.formula="⊤"/>
<org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="cons(LH, LT)" org.eventb.theory.core.formula="LH = zero ∧ BaseNIsZeroInternal(LT)"/>
</org.eventb.theory.core.recursiveOperatorDefinition>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.newOperatorDefinition name="5" org.eventb.core.label="BNumIsZero" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="false" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.directOperatorDefinition name="'" org.eventb.theory.core.formula="BaseNIsZeroInternal(BNumList(n))"/>
<org.eventb.theory.core.operatorArgument name="(" org.eventb.core.expression="BNum" org.eventb.core.identifier="n"/>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.newOperatorDefinition name="2" org.eventb.core.comment="There are no trailing zeros in the list" org.eventb.core.label="BaseNIsNormalInternal" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="false" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="List(pNat)" org.eventb.core.identifier="L"/>
<org.eventb.theory.core.recursiveOperatorDefinition name=")" org.eventb.theory.core.inductiveArgument="L">
<org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="nil" org.eventb.theory.core.formula="⊤"/>
<org.eventb.theory.core.recursiveDefinitionCase name=")" org.eventb.core.expression="cons(LH, LT)" org.eventb.theory.core.formula="(LT = nil ∧ LH ≠ zero) ∨ (LT ≠ nil ∧ BaseNIsNormalInternal(LT))"/>
</org.eventb.theory.core.recursiveOperatorDefinition>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.newOperatorDefinition name="*" org.eventb.core.comment="All values in the list are less than the base" org.eventb.core.label="BNumIsWD" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="false" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.recursiveOperatorDefinition name="'" org.eventb.theory.core.inductiveArgument="L">
<org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="nil" org.eventb.theory.core.formula="⊤ ∧ two pLeq B"/>
<org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="cons(L_head, L_tail)" org.eventb.theory.core.formula="two pLeq B ∧ L_head pLeq pDecrement(B) ∧ BNumIsWD(L_tail, B)"/>
</org.eventb.theory.core.recursiveOperatorDefinition>
<org.eventb.theory.core.operatorArgument name="(" org.eventb.core.expression="List(pNat)" org.eventb.core.identifier="L"/>
<org.eventb.theory.core.operatorArgument name=")" org.eventb.core.expression="pNat" org.eventb.core.identifier="B"/>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.newOperatorDefinition name="." org.eventb.core.label="BNumIsNormal" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="false" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="List(pNat) × pNat" org.eventb.core.identifier="Num"/>
<org.eventb.theory.core.directOperatorDefinition name="(" org.eventb.theory.core.formula="BNumIsWD(prj1(Num), prj2(Num)) ∧ BaseNIsNormalInternal(BNumList(Num))"/>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.newOperatorDefinition name="(" org.eventb.core.label="BNumNorm" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.directOperatorDefinition name="'" org.eventb.theory.core.formula="{ Num ↦ Base ∣ Num ∈ List(pNat) ∧ Base ∈ pNat ∧ BNumIsNormal(Num ↦ Base) }"/>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.newOperatorDefinition name="," org.eventb.core.label="BaseNDecrementInternal" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="List(pNat)" org.eventb.core.identifier="L"/>
<org.eventb.theory.core.operatorArgument name="(" org.eventb.core.expression="pNat" org.eventb.core.identifier="B"/>
<org.eventb.theory.core.recursiveOperatorDefinition name="*" org.eventb.theory.core.inductiveArgument="L">
<org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="nil" org.eventb.theory.core.formula="nil ⦂ List(pNat)"/>
<org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="cons(LH, LT)" org.eventb.theory.core.formula="COND(LH = one ∧ LT = nil,&#10;  nil,&#10;  COND(LH = zero,&#10;    COND(LT = cons(suc(zero), nil), &#10;      cons(pDecrement(B), nil),&#10;      cons(pDecrement(B), BaseNDecrementInternal(LT, B))),&#10;    cons(pDecrement(LH), LT)))"/>
</org.eventb.theory.core.recursiveOperatorDefinition>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.newOperatorDefinition name="7" org.eventb.core.label="BaseNDecrement" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="BNum" org.eventb.core.identifier="n"/>
<org.eventb.theory.core.directOperatorDefinition name="(" org.eventb.theory.core.formula="BaseNDecrementInternal(BNumList(n), BNumBase(n)) ↦ BNumBase(n)"/>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.newOperatorDefinition name="&gt;" org.eventb.core.comment="Least Significant Digit" org.eventb.core.label="BNumLSDInternal" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.recursiveOperatorDefinition name="'" org.eventb.theory.core.inductiveArgument="L">
<org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="nil" org.eventb.theory.core.formula="zero"/>
<org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="cons(LH, LT)" org.eventb.theory.core.formula="LH"/>
</org.eventb.theory.core.recursiveOperatorDefinition>
<org.eventb.theory.core.operatorArgument name="(" org.eventb.core.expression="List(pNat)" org.eventb.core.identifier="L"/>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.newOperatorDefinition name="?" org.eventb.core.label="BNumLSD" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="BNum" org.eventb.core.identifier="n"/>
<org.eventb.theory.core.directOperatorDefinition name="(" org.eventb.theory.core.formula="BNumLSDInternal(BNumList(n)) ↦ BNumBase(n)"/>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.newOperatorDefinition name="@" org.eventb.core.label="BNumShiftLeftInternal" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="List(pNat)" org.eventb.core.identifier="L"/>
<org.eventb.theory.core.recursiveOperatorDefinition name="(" org.eventb.theory.core.inductiveArgument="L">
<org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="nil" org.eventb.theory.core.formula="nil ⦂ List(pNat)"/>
<org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="cons(LH, LT)" org.eventb.theory.core.formula="LT"/>
</org.eventb.theory.core.recursiveOperatorDefinition>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.newOperatorDefinition name="A" org.eventb.core.comment="The number representation is backwards&#10;So shift left does what shift right would&#10;do for our numbers." org.eventb.core.label="BNumShiftLeft" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="BNum" org.eventb.core.identifier="n"/>
<org.eventb.theory.core.directOperatorDefinition name="(" org.eventb.theory.core.formula="BNumShiftLeftInternal(BNumList(n)) ↦ BNumBase(n)"/>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.newOperatorDefinition name="C" org.eventb.core.label="WGoodDecr" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
<org.eventb.theory.core.directOperatorDefinition name="'" org.eventb.theory.core.formula="COND(prj1(xy) = nil, nil ↦ suc(suc(zero)), BaseNDecrementInternal(prj1(xy), suc(prj2(xy))) ↦ suc(prj2(xy)))"/>
<org.eventb.theory.core.operatorArgument name="(" org.eventb.core.expression="BNum" org.eventb.core.identifier="xy"/>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.importTheoryProject name="+" org.eventb.theory.core.importTheoryProject="/PeanoNaturals">
<org.eventb.theory.core.importTheory name="'" org.eventb.theory.core.importTheory="/PeanoNaturals/pNat.dtf|org.eventb.theory.core.deployedTheoryRoot#pNat"/>
</org.eventb.theory.core.importTheoryProject>
<org.eventb.theory.core.importTheoryProject name="'" org.eventb.theory.core.importTheoryProject="/ListTheory">
<org.eventb.theory.core.importTheory name="'" org.eventb.theory.core.importTheory="/ListTheory/List.dtf|org.eventb.theory.core.deployedTheoryRoot#List"/>
</org.eventb.theory.core.importTheoryProject>
<org.eventb.theory.core.theorem name="8" org.eventb.core.label="EndingWithZerosIsNotNormal" org.eventb.core.predicate="∀x · x ≠ nil ∧ BaseNIsZeroInternal(x) ⇒ (∀B·¬BNumIsNormal(x ↦ B))"/>
<org.eventb.theory.core.theorem name=":" org.eventb.core.label="BNDecrementMaintainsNormalityCororally" org.eventb.core.predicate="∀L·∀B·L↦B ∈ BNumNorm ⇒ BaseNDecrement(L↦B) ∈ BNumNorm"/>
<org.eventb.theory.core.theorem name="9" org.eventb.core.label="BNDecrementMaintainsNormality" org.eventb.core.predicate="∀num·num ∈ BNumNorm ⇒ BaseNDecrement(num) ∈ BNumNorm"/>
<org.eventb.theory.core.theorem name="B" org.eventb.core.label="Shift left maintains normality" org.eventb.core.predicate="∀x·x ∈ BNumNorm ⇒ BNumShiftLeft(x) ∈ BNumNorm"/>
<org.eventb.theory.core.theorem name="=" org.eventb.core.label="WGoodDecr Maintains Normality Cororally" org.eventb.core.predicate="∀x·x∈BNumNorm ⇒ BNumList(x) ↦ suc(BNumBase(x)) ∈ BNumNorm"/>
<org.eventb.theory.core.theorem name="D" org.eventb.core.label="WGood is closed" org.eventb.core.predicate="∀a·a ∈ BNumNorm ⇒ WGoodDecr(a) ∈ BNumNorm"/>
</org.eventb.theory.core.theoryRoot>
