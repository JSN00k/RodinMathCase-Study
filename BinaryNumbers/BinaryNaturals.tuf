<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.theory.core.theoryRoot org.eventb.core.comment="My numbers are backwards." org.eventb.core.configuration="org.eventb.theory.core.thy">
<org.eventb.theory.core.newOperatorDefinition name=";" org.eventb.core.label="bn_Add" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="INFIX">
<org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="List(BOOL)" org.eventb.core.identifier="x"/>
<org.eventb.theory.core.operatorArgument name="(" org.eventb.core.expression="List(BOOL)" org.eventb.core.identifier="y"/>
<org.eventb.theory.core.recursiveOperatorDefinition name="+" org.eventb.theory.core.inductiveArgument="x">
<org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="nil" org.eventb.theory.core.formula="y"/>
<org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.comment="The initial COND (y = nil) makes the operator symetric" org.eventb.core.expression="cons(xB, xs)" org.eventb.theory.core.formula="COND(y = nil, cons(xB, xs),&#10;  COND(xB = TRUE ∧ bn_LSB(y) = TRUE, cons(FALSE, bn_increment(xs bn_Add bn_shiftLeft1(y))),&#10;    COND(¬(xB = TRUE) ∧ ¬(bn_LSB(y) = TRUE), cons(FALSE, xs bn_Add bn_shiftLeft1(y)),&#10;    cons(TRUE, xs bn_Add bn_shiftLeft1(y)))))"/>
</org.eventb.theory.core.recursiveOperatorDefinition>
</org.eventb.theory.core.newOperatorDefinition>
<org.eventb.theory.core.theorem name="v" org.eventb.core.label="x bn_Add nil = x" org.eventb.core.predicate="∀x·x bn_Add nil = x"/>
<org.eventb.theory.core.theorem name="x" org.eventb.core.label="ReverseExpand" org.eventb.core.predicate="∀x, yB, yT· x bn_Add cons(yB, yT) =  &#10;  COND(yB = TRUE ∧ bn_LSB(x) = TRUE, cons(FALSE, bn_increment(bn_shiftLeft1(x) bn_Add yT)),&#10;    COND(¬(yB = TRUE) ∧ ¬(bn_LSB(x) = TRUE), cons(FALSE, bn_shiftLeft1(x) bn_Add yT),&#10;    cons(TRUE, bn_shiftLeft1(x) bn_Add yT)))"/>
<org.eventb.theory.core.theorem name="'." org.eventb.core.label="expand cons" org.eventb.core.predicate="∀x·cons(FALSE, x) bn_Eq x bn_Add x"/>
<org.eventb.theory.core.theorem name="'/" org.eventb.core.label="expand Cons TRUE" org.eventb.core.predicate="∀x·cons(TRUE, x) bn_Eq bn_increment(x bn_Add x)"/>
<org.eventb.theory.core.theorem name="'+" org.eventb.core.label="hasSetBit(x) ⇒ hasSetBit(x bn_Add y)" org.eventb.core.predicate="∀x, y·bn_hasSetBit(x) ⇒ bn_hasSetBit(x bn_Add y)"/>
<org.eventb.theory.core.theorem name="{" org.eventb.core.label="zero bn_add Corrally1" org.eventb.core.predicate="∀x, y·bn_isZero(x) ⇒ x bn_Add y bn_Eq y"/>
<org.eventb.theory.core.theorem name="|" org.eventb.core.label="zero bn_add Corrally2" org.eventb.core.predicate="∀x, y· x bn_Add y = y ⇒  bn_isZero(x)"/>
<org.eventb.theory.core.theorem name="z" org.eventb.core.label="zero bn_add x = x" org.eventb.core.predicate="∀x, y·bn_isZero(y) ⇔ y bn_Add x = x"/>
<org.eventb.theory.core.theorem name="'(" org.eventb.core.label="zero Add Zero = zero" org.eventb.core.predicate="∀x, y · bn_isZero(x) ∧ bn_isZero(y) ⇔ bn_isZero(x bn_Add y)"/>
<org.eventb.theory.core.theorem name="'-" org.eventb.core.label="CountBitsImpl1" org.eventb.core.predicate="∀x, y·bn_countBits(x bn_Add y) ≥ bn_countBits(x) "/>
<org.eventb.theory.core.theorem name="'," org.eventb.core.label="add nil" org.eventb.core.predicate="∀x·x bn_Add nil bn_Eq nil"/>
<org.eventb.theory.core.theorem name="'*" org.eventb.core.label="add Equality" org.eventb.core.predicate="∀x, y, z · x bn_Eq y ⇔ z bn_Add x bn_Eq z bn_Add y"/>
<org.eventb.theory.core.theorem name="')" org.eventb.core.label="bn_Add zero" org.eventb.core.predicate="∀x, y· bn_isZero(y) ⇔ x bn_Add y bn_Eq x"/>
<org.eventb.theory.core.theorem name="''" org.eventb.core.label="incrementOutAddition" org.eventb.core.predicate="∀x, y·bn_increment(x) bn_Add y bn_Eq bn_increment(x bn_Add y)"/>
<org.eventb.theory.core.theorem name="~" org.eventb.core.label="EqualNumsAddToSame" org.eventb.core.predicate="∀x, y, z·y bn_Eq z ⇒ x bn_Add y bn_Eq x bn_Add z"/>
<org.eventb.theory.core.theorem name="y" org.eventb.core.label="AdditionReduction" org.eventb.core.predicate="∀x, y, z · x bn_Add y bn_Eq x bn_Add z ⇒ y bn_Eq z"/>
<org.eventb.theory.core.theorem name="}" org.eventb.core.label="add xOR LSBs" org.eventb.core.predicate="∀x, y· bn_LSB(x) xOR bn_LSB(y) = bn_LSB(x bn_Add y)"/>
<org.eventb.theory.core.theorem name="u" org.eventb.core.label="x + zero = x" org.eventb.core.predicate="∀x, y· bn_isZero(y) ⇔ x bn_Add y bn_Eq x"/>
<org.eventb.theory.core.theorem name="t" org.eventb.core.label="zero + zero = zero" org.eventb.core.predicate="∀x, y· bn_isZero(x) ∧ bn_isZero(y) ⇔ bn_isZero(x bn_Add y)"/>
<org.eventb.theory.core.theorem name="q" org.eventb.core.label="notZero add isNotZero" org.eventb.core.predicate="∀x, y·¬(bn_isZero(x)) ⇒ ¬bn_isZero(x bn_Add y)"/>
<org.eventb.theory.core.theorem name="p" org.eventb.core.label="add increment ¬zero" org.eventb.core.predicate="∀x, y· ¬bn_isZero(x bn_Add bn_increment(y))"/>
<org.eventb.theory.core.theorem name="D" org.eventb.core.label="bn_AddZero" org.eventb.core.predicate="∀x·x bn_Add nil bn_Eq x"/>
<org.eventb.theory.core.theorem name="j" org.eventb.core.label="NotAddingZero" org.eventb.core.predicate="∀x, y·¬(bn_isZero(x)) ∧ ¬(bn_isZero(y)) ⇔ ¬(bn_isZero(x bn_Add y))"/>
<org.eventb.theory.core.theorem name="h" org.eventb.core.label="bn_AddAllZeros" org.eventb.core.predicate="∀x,y· bn_isZero(y) ⇔ x bn_Add y bn_Eq x"/>
<org.eventb.theory.core.theorem name="i" org.eventb.core.label="AdditionEquality" org.eventb.core.predicate="∀x, y, z·x bn_Eq y ⇔ x bn_Add z = y bn_Add z"/>
<org.eventb.theory.core.theorem name="C" org.eventb.core.label="bn_appendList" org.eventb.core.predicate="∀x· bn_concatonate(x, nil) = x"/>
<org.eventb.theory.core.theorem name="g" org.eventb.core.label="Commutivity" org.eventb.core.predicate="∀x, y·(x bn_Add y) bn_Eq (y bn_Add x)"/>
<org.eventb.theory.core.theorem name="e" org.eventb.core.label="bn_add_intBitCount" org.eventb.core.predicate="∀x, y·bn_countBits(x) ≥ bn_countBits(y) ⇒ bn_countBits(x bn_Add y) ≥ bn_countBits(x)"/>
<org.eventb.theory.core.theorem name="d" org.eventb.core.label="shiftLeftZero" org.eventb.core.predicate="∀x, y·¬(bn_isZero(x bn_Add bn_shiftLeft1(y))) ⇒ ¬(bn_isZero(x bn_Add y))"/>
<org.eventb.theory.core.theorem name="b" org.eventb.core.label="zero add zero = zero" org.eventb.core.predicate="∀x, y· bn_isZero(x bn_Add y) ⇔ bn_isZero(x) ∧ bn_isZero(y)"/>
<org.eventb.theory.core.importTheoryProject name="K" org.eventb.theory.core.importTheoryProject="/Maths">
<org.eventb.theory.core.importTheory name="'" org.eventb.theory.core.importTheory="/Maths/NaturalsMultiply.dtf|org.eventb.theory.core.deployedTheoryRoot#NaturalsMultiply"/>
</org.eventb.theory.core.importTheoryProject>
<org.eventb.theory.core.importTheoryProject name="W" org.eventb.theory.core.importTheoryProject="/BOOL">
<org.eventb.theory.core.importTheory name="'" org.eventb.theory.core.importTheory="/BOOL/BOOL.dtf|org.eventb.theory.core.deployedTheoryRoot#BOOL"/>
</org.eventb.theory.core.importTheoryProject>
<org.eventb.theory.core.importTheoryProject name="\" org.eventb.theory.core.importTheoryProject="/BinaryNumbers">
<org.eventb.theory.core.importTheory name="'" org.eventb.theory.core.importTheory="/BinaryNumbers/BitwiseOps.dtf|org.eventb.theory.core.deployedTheoryRoot#BitwiseOps"/>
<org.eventb.theory.core.importTheory name="(" org.eventb.theory.core.importTheory="/BinaryNumbers/BinaryEquality.dtf|org.eventb.theory.core.deployedTheoryRoot#BinaryEquality"/>
<org.eventb.theory.core.importTheory name="*" org.eventb.theory.core.importTheory="/BinaryNumbers/IncrementNaturals.dtf|org.eventb.theory.core.deployedTheoryRoot#IncrementNaturals"/>
</org.eventb.theory.core.importTheoryProject>
</org.eventb.theory.core.theoryRoot>
